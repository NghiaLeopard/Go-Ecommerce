// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: Product.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const checkProduct = `-- name: CheckProduct :one
SELECT "_id" FROM "Product"
WHERE "_id" = $1 LIMIT 1
`

func (q *Queries) CheckProduct(ctx context.Context, ID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkProduct, ID)
	var _id int64
	err := row.Scan(&_id)
	return _id, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO "Product" (
  "name","image","countInStock","description","type","status","slug","price","discount","discountStartDate","discountEndDate","location"
) VALUES (
  $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12
)
RETURNING _id, name, image, "countInStock", description, sold, discount, "discountStartDate", "discountEndDate", type, status, slug, price, location, views, create_at
`

type CreateProductParams struct {
	Name              string    `json:"name"`
	Image             string    `json:"image"`
	CountInStock      int32     `json:"countInStock"`
	Description       string    `json:"description"`
	Type              int32     `json:"type"`
	Status            int32     `json:"status"`
	Slug              string    `json:"slug"`
	Price             int32     `json:"price"`
	Discount          int32     `json:"discount"`
	DiscountStartDate time.Time `json:"discountStartDate"`
	DiscountEndDate   time.Time `json:"discountEndDate"`
	Location          int32     `json:"location"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Name,
		arg.Image,
		arg.CountInStock,
		arg.Description,
		arg.Type,
		arg.Status,
		arg.Slug,
		arg.Price,
		arg.Discount,
		arg.DiscountStartDate,
		arg.DiscountEndDate,
		arg.Location,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
	)
	return i, err
}

const createProductLike = `-- name: CreateProductLike :exec
INSERT INTO "Product_liked" (
  "product_id","user_id"
) VALUES (
  $1, $2
)
`

type CreateProductLikeParams struct {
	ProductID int32 `json:"product_id"`
	UserID    int32 `json:"user_id"`
}

func (q *Queries) CreateProductLike(ctx context.Context, arg CreateProductLikeParams) error {
	_, err := q.db.ExecContext(ctx, createProductLike, arg.ProductID, arg.UserID)
	return err
}

const createProductUniqueView = `-- name: CreateProductUniqueView :exec
INSERT INTO "Product_UniqueView" (
  "product_id","user_id"
) VALUES (
  $1, $2
)
`

type CreateProductUniqueViewParams struct {
	ProductID int32 `json:"product_id"`
	UserID    int32 `json:"user_id"`
}

func (q *Queries) CreateProductUniqueView(ctx context.Context, arg CreateProductUniqueViewParams) error {
	_, err := q.db.ExecContext(ctx, createProductUniqueView, arg.ProductID, arg.UserID)
	return err
}

const deleteLikedProductByUserId = `-- name: DeleteLikedProductByUserId :exec
DELETE FROM "Product_liked"
WHERE user_id = $1
`

func (q *Queries) DeleteLikedProductByUserId(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, deleteLikedProductByUserId, userID)
	return err
}

const deleteManyProductsByIds = `-- name: DeleteManyProductsByIds :exec
DELETE FROM "Product"
WHERE "_id" = ANY($1::bigint[])
`

func (q *Queries) DeleteManyProductsByIds(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.ExecContext(ctx, deleteManyProductsByIds, pq.Array(dollar_1))
	return err
}

const deleteProductById = `-- name: DeleteProductById :exec
DELETE FROM "Product"
WHERE "_id" = $1
`

func (q *Queries) DeleteProductById(ctx context.Context, ID int64) error {
	_, err := q.db.ExecContext(ctx, deleteProductById, ID)
	return err
}

const getAllProductAdmin = `-- name: GetAllProductAdmin :many
SELECT p."_id",p.name,p."countInStock",p.image,p.price,p.slug,p.status,
json_build_object('_id', pt."_id", 'name', pt.name) AS "type",
COUNT(p."_id") OVER() AS "totalCount" FROM "Product" p
JOIN "Product_Type" pt ON p.type = pt."_id"
WHERE 
  CASE
		WHEN $3 :: text != '' THEN (
			p.name ILIKE concat('%', $3, '%')
		)
		ELSE true
	END
  AND CASE
		WHEN $4 IN (1,2)  THEN
			status = $4
		ELSE true
	END
  AND CASE
		WHEN $5 :: integer > 0  THEN
			type = $5
		ELSE true
	END
ORDER BY 
  CASE 
        WHEN $6 ::varchar = 'name asc' THEN p.name END ASC,
  CASE 
        WHEN $6 = 'name desc' THEN p.name END DESC,
  CASE 
        WHEN $6 = 'slug asc' THEN p.slug END ASC,
  CASE 
        WHEN $6 = 'slug desc' THEN p.slug END DESC,
  CASE 
        WHEN $6 = 'type asc' THEN type END ASC,
  CASE 
        WHEN $6 = 'type desc' THEN type END DESC,
  CASE 
        WHEN $6 = 'price asc' THEN price END ASC,
  CASE 
        WHEN $6 = 'price desc' THEN price END DESC,
  CASE 
        WHEN $6 = 'countInStock asc' THEN "countInStock" END ASC,
  CASE 
        WHEN $6 = 'countInStock desc' THEN "countInStock" END DESC,
  CASE 
        WHEN $6 = 'status asc' THEN status END ASC,
  CASE 
        WHEN $6 = 'status desc' THEN status END DESC,
  CASE 
        WHEN $6 = 'created_date asc' THEN p.create_at END ASC,
  CASE 
        WHEN $6 = 'created_date desc' THEN p.create_at END DESC
LIMIT $1
OFFSET $2
`

type GetAllProductAdminParams struct {
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
	Search  string      `json:"search"`
	Status  interface{} `json:"status"`
	Type    int32       `json:"type"`
	OrderBy string      `json:"order_by"`
}

type GetAllProductAdminRow struct {
	ID           int64           `json:"_id"`
	Name         string          `json:"name"`
	CountInStock int32           `json:"countInStock"`
	Image        string          `json:"image"`
	Price        int32           `json:"price"`
	Slug         string          `json:"slug"`
	Status       int32           `json:"status"`
	Type         json.RawMessage `json:"type"`
	TotalCount   int64           `json:"totalCount"`
}

func (q *Queries) GetAllProductAdmin(ctx context.Context, arg GetAllProductAdminParams) ([]GetAllProductAdminRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProductAdmin,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.Status,
		arg.Type,
		arg.OrderBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductAdminRow{}
	for rows.Next() {
		var i GetAllProductAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CountInStock,
			&i.Image,
			&i.Price,
			&i.Slug,
			&i.Status,
			&i.Type,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProductLike = `-- name: GetAllProductLike :many
SELECT p._id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",COUNT(p."_id") OVER() AS "totalCount",
CASE WHEN COUNT(l."user_id") > 0 THEN json_agg(l."user_id") ELSE '[]'::json END AS "likedBy",
CASE WHEN COUNT(v."user_id") > 0 THEN json_agg(v."user_id") ELSE '[]'::json END AS "uniqueViews"
FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p."_id"
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p."_id"
WHERE l.user_id = $1 AND ($4 ::text = '' or name ILIKE concat('%',$4,'%'))   
GROUP BY p."_id"
ORDER BY MAX(l.like_date) asc
LIMIT $2
OFFSET $3
`

type GetAllProductLikeParams struct {
	UserID int32  `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Search string `json:"search"`
}

type GetAllProductLikeRow struct {
	ID                int64           `json:"_id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	TotalCount        int64           `json:"totalCount"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetAllProductLike(ctx context.Context, arg GetAllProductLikeParams) ([]GetAllProductLikeRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProductLike,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductLikeRow{}
	for rows.Next() {
		var i GetAllProductLikeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Image,
			&i.CountInStock,
			&i.Description,
			&i.Sold,
			&i.Discount,
			&i.DiscountStartDate,
			&i.DiscountEndDate,
			&i.Type,
			&i.Status,
			&i.Slug,
			&i.Price,
			&i.Location,
			&i.Views,
			&i.CreateAt,
			&i.TotalLikes,
			&i.TotalCount,
			&i.LikedBy,
			&i.UniqueViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProductPublic = `-- name: GetAllProductPublic :many
SELECT p._id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",COUNT(p."_id") OVER() AS "totalCount",
CASE WHEN COUNT(l."user_id") > 0 THEN json_agg(l."user_id") ELSE '[]'::json END AS "likedBy",
CASE WHEN COUNT(v."user_id") > 0 THEN json_agg(v."user_id") ELSE '[]'::json END AS "uniqueViews"
FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p."_id"
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p."_id"
WHERE 
  CASE
		WHEN $3 :: text != '' THEN (
			p.name ILIKE concat('%', $3, '%')
		)
		ELSE true
	END
  AND CASE
		WHEN $4 IN (1,2)  THEN
			status = $4
		ELSE true
	END
  AND CASE
		WHEN $5 :: integer > 0  THEN
			type = $5
		ELSE true
	END
  AND CASE
		WHEN $6 :: integer > 0  THEN
			price >= $6
		ELSE true
	END
  AND CASE
		WHEN $7 :: integer > 0  THEN
			price <= $7
		ELSE true
	END
GROUP BY p."_id"
ORDER BY create_at ASC
LIMIT $1
OFFSET $2
`

type GetAllProductPublicParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	Search   string      `json:"search"`
	Status   interface{} `json:"status"`
	Type     int32       `json:"type"`
	Minprice int32       `json:"minprice"`
	Maxprice int32       `json:"maxprice"`
}

type GetAllProductPublicRow struct {
	ID                int64           `json:"_id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	TotalCount        int64           `json:"totalCount"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetAllProductPublic(ctx context.Context, arg GetAllProductPublicParams) ([]GetAllProductPublicRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProductPublic,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.Status,
		arg.Type,
		arg.Minprice,
		arg.Maxprice,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductPublicRow{}
	for rows.Next() {
		var i GetAllProductPublicRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Image,
			&i.CountInStock,
			&i.Description,
			&i.Sold,
			&i.Discount,
			&i.DiscountStartDate,
			&i.DiscountEndDate,
			&i.Type,
			&i.Status,
			&i.Slug,
			&i.Price,
			&i.Location,
			&i.Views,
			&i.CreateAt,
			&i.TotalLikes,
			&i.TotalCount,
			&i.LikedBy,
			&i.UniqueViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProductRelated = `-- name: GetAllProductRelated :many
SELECT p._id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",COUNT(p."_id") OVER() AS "totalCount",
CASE WHEN COUNT(l."user_id") > 0 THEN json_agg(l."user_id") ELSE '[]'::json END AS "likedBy",
CASE WHEN COUNT(v."user_id") > 0 THEN json_agg(v."user_id") ELSE '[]'::json END AS "uniqueViews"
FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p."_id"
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p."_id"
WHERE p.type = $1 AND p."_id" <> $2
GROUP BY p."_id"
LIMIT $3
OFFSET $4
`

type GetAllProductRelatedParams struct {
	Type   int32 `json:"type"`
	ID     int64 `json:"_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllProductRelatedRow struct {
	ID                int64           `json:"_id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	TotalCount        int64           `json:"totalCount"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetAllProductRelated(ctx context.Context, arg GetAllProductRelatedParams) ([]GetAllProductRelatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProductRelated,
		arg.Type,
		arg.ID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductRelatedRow{}
	for rows.Next() {
		var i GetAllProductRelatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Image,
			&i.CountInStock,
			&i.Description,
			&i.Sold,
			&i.Discount,
			&i.DiscountStartDate,
			&i.DiscountEndDate,
			&i.Type,
			&i.Status,
			&i.Slug,
			&i.Price,
			&i.Location,
			&i.Views,
			&i.CreateAt,
			&i.TotalLikes,
			&i.TotalCount,
			&i.LikedBy,
			&i.UniqueViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProductView = `-- name: GetAllProductView :many
SELECT p._id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",COUNT(p."_id") OVER() AS "totalCount",
CASE WHEN COUNT(l."user_id") > 0 THEN json_agg(l."user_id") ELSE '[]'::json END AS "likedBy",
CASE WHEN COUNT(v."user_id") > 0 THEN json_agg(v."user_id") ELSE '[]'::json END AS "uniqueViews"
FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p."_id"
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p."_id"
WHERE v.user_id = $1 AND ($4 ::text = '' or name ILIKE concat('%',$4,'%'))
GROUP BY p."_id" 
ORDER BY MAX(v.view_date) asc
LIMIT $2
OFFSET $3
`

type GetAllProductViewParams struct {
	UserID int32  `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Search string `json:"search"`
}

type GetAllProductViewRow struct {
	ID                int64           `json:"_id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	TotalCount        int64           `json:"totalCount"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetAllProductView(ctx context.Context, arg GetAllProductViewParams) ([]GetAllProductViewRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProductView,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductViewRow{}
	for rows.Next() {
		var i GetAllProductViewRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Image,
			&i.CountInStock,
			&i.Description,
			&i.Sold,
			&i.Discount,
			&i.DiscountStartDate,
			&i.DiscountEndDate,
			&i.Type,
			&i.Status,
			&i.Slug,
			&i.Price,
			&i.Location,
			&i.Views,
			&i.CreateAt,
			&i.TotalLikes,
			&i.TotalCount,
			&i.LikedBy,
			&i.UniqueViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductById = `-- name: GetProductById :one
SELECT p._id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p."_id"
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p."_id"
WHERE p."_id" = $1 
GROUP BY p."_id"
LIMIT 1
`

type GetProductByIdRow struct {
	ID                int64           `json:"_id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetProductById(ctx context.Context, ID int64) (GetProductByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getProductById, ID)
	var i GetProductByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT p._id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p."_id"
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p."_id"
WHERE p.slug = $1 
GROUP BY p."_id"
LIMIT 1
`

type GetProductBySlugRow struct {
	ID                int64           `json:"_id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (GetProductBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getProductBySlug, slug)
	var i GetProductBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const getProductPublicById = `-- name: GetProductPublicById :one
SELECT p._id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p."_id"
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p."_id"
WHERE p."_id" = $1 
GROUP BY p."_id"
LIMIT 1
`

type GetProductPublicByIdRow struct {
	ID                int64           `json:"_id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetProductPublicById(ctx context.Context, ID int64) (GetProductPublicByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getProductPublicById, ID)
	var i GetProductPublicByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const getProductTypeBySlug = `-- name: GetProductTypeBySlug :one
SELECT "_id",type from "Product"
WHERE slug = $1 LIMIT 1
`

type GetProductTypeBySlugRow struct {
	ID   int64 `json:"_id"`
	Type int32 `json:"type"`
}

func (q *Queries) GetProductTypeBySlug(ctx context.Context, slug string) (GetProductTypeBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getProductTypeBySlug, slug)
	var i GetProductTypeBySlugRow
	err := row.Scan(&i.ID, &i.Type)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE "Product" SET name = $1,image = $2,"countInStock" = $3,description = $4,type = $5,status = $6,slug = $7,price = $8,discount = $9,"discountStartDate" = $10,"discountEndDate" = $11,location = $12
WHERE "_id" = $13
RETURNING _id, name, image, "countInStock", description, sold, discount, "discountStartDate", "discountEndDate", type, status, slug, price, location, views, create_at
`

type UpdateProductParams struct {
	Name              string    `json:"name"`
	Image             string    `json:"image"`
	CountInStock      int32     `json:"countInStock"`
	Description       string    `json:"description"`
	Type              int32     `json:"type"`
	Status            int32     `json:"status"`
	Slug              string    `json:"slug"`
	Price             int32     `json:"price"`
	Discount          int32     `json:"discount"`
	DiscountStartDate time.Time `json:"discountStartDate"`
	DiscountEndDate   time.Time `json:"discountEndDate"`
	Location          int32     `json:"location"`
	ID                int64     `json:"_id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.Name,
		arg.Image,
		arg.CountInStock,
		arg.Description,
		arg.Type,
		arg.Status,
		arg.Slug,
		arg.Price,
		arg.Discount,
		arg.DiscountStartDate,
		arg.DiscountEndDate,
		arg.Location,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
	)
	return i, err
}

const updateViewProduct = `-- name: UpdateViewProduct :exec
UPDATE "Product" SET views = $1
WHERE "_id" = $2
`

type UpdateViewProductParams struct {
	Views int32 `json:"views"`
	ID    int64 `json:"_id"`
}

func (q *Queries) UpdateViewProduct(ctx context.Context, arg UpdateViewProductParams) error {
	_, err := q.db.ExecContext(ctx, updateViewProduct, arg.Views, arg.ID)
	return err
}
