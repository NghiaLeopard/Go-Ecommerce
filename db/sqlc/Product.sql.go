// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: Product.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO "Product" (
  "name","image","countInStock","description","type","status","slug","price","discount","discountStartDate","discountEndDate","location"
) VALUES (
  $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12
)
RETURNING id, name, image, "countInStock", description, sold, discount, "discountStartDate", "discountEndDate", type, status, slug, price, location, views, create_at
`

type CreateProductParams struct {
	Name              string    `json:"name"`
	Image             string    `json:"image"`
	CountInStock      int32     `json:"countInStock"`
	Description       string    `json:"description"`
	Type              int32     `json:"type"`
	Status            int32     `json:"status"`
	Slug              string    `json:"slug"`
	Price             int32     `json:"price"`
	Discount          int32     `json:"discount"`
	DiscountStartDate time.Time `json:"discountStartDate"`
	DiscountEndDate   time.Time `json:"discountEndDate"`
	Location          int32     `json:"location"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Name,
		arg.Image,
		arg.CountInStock,
		arg.Description,
		arg.Type,
		arg.Status,
		arg.Slug,
		arg.Price,
		arg.Discount,
		arg.DiscountStartDate,
		arg.DiscountEndDate,
		arg.Location,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
	)
	return i, err
}

const createProductLike = `-- name: CreateProductLike :exec
INSERT INTO "Product_liked" (
  "product_id","user_id"
) VALUES (
  $1, $2
)
`

type CreateProductLikeParams struct {
	ProductID int32 `json:"product_id"`
	UserID    int32 `json:"user_id"`
}

func (q *Queries) CreateProductLike(ctx context.Context, arg CreateProductLikeParams) error {
	_, err := q.db.ExecContext(ctx, createProductLike, arg.ProductID, arg.UserID)
	return err
}

const createProductUniqueView = `-- name: CreateProductUniqueView :exec
INSERT INTO "Product_UniqueView" (
  "product_id","user_id"
) VALUES (
  $1, $2
)
`

type CreateProductUniqueViewParams struct {
	ProductID int32 `json:"product_id"`
	UserID    int32 `json:"user_id"`
}

func (q *Queries) CreateProductUniqueView(ctx context.Context, arg CreateProductUniqueViewParams) error {
	_, err := q.db.ExecContext(ctx, createProductUniqueView, arg.ProductID, arg.UserID)
	return err
}

const deleteLikedProductByUserId = `-- name: DeleteLikedProductByUserId :exec
DELETE FROM "Product_liked"
WHERE user_id = $1
`

func (q *Queries) DeleteLikedProductByUserId(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, deleteLikedProductByUserId, userID)
	return err
}

const deleteManyProductsByIds = `-- name: DeleteManyProductsByIds :exec
DELETE FROM "Product"
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteManyProductsByIds(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.ExecContext(ctx, deleteManyProductsByIds, pq.Array(dollar_1))
	return err
}

const deleteProductById = `-- name: DeleteProductById :exec
DELETE FROM "Product"
WHERE id = $1
`

func (q *Queries) DeleteProductById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProductById, id)
	return err
}

const getAllProductLike = `-- name: GetAllProductLike :many
SELECT p.id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",COUNT(p.id) OVER() AS "totalCount",
CASE WHEN COUNT(l."user_id") > 0 THEN json_agg(l."user_id") ELSE '[]'::json END AS "likedBy",
CASE WHEN COUNT(v."user_id") > 0 THEN json_agg(v."user_id") ELSE '[]'::json END AS "uniqueViews"
FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p.id
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p.id
WHERE l.user_id = $1 AND ($4 ::text = '' or name ILIKE concat('%',$4,'%'))     
GROUP BY p.id
ORDER BY MAX(l.like_date) asc
LIMIT $2
OFFSET $3
`

type GetAllProductLikeParams struct {
	UserID int32  `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Search string `json:"search"`
}

type GetAllProductLikeRow struct {
	ID                int64           `json:"id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	TotalCount        int64           `json:"totalCount"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetAllProductLike(ctx context.Context, arg GetAllProductLikeParams) ([]GetAllProductLikeRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProductLike,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductLikeRow{}
	for rows.Next() {
		var i GetAllProductLikeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Image,
			&i.CountInStock,
			&i.Description,
			&i.Sold,
			&i.Discount,
			&i.DiscountStartDate,
			&i.DiscountEndDate,
			&i.Type,
			&i.Status,
			&i.Slug,
			&i.Price,
			&i.Location,
			&i.Views,
			&i.CreateAt,
			&i.TotalLikes,
			&i.TotalCount,
			&i.LikedBy,
			&i.UniqueViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProductView = `-- name: GetAllProductView :many
SELECT p.id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
CASE WHEN COUNT(l."user_id") > 0 THEN json_agg(l."user_id") ELSE '[]'::json END AS "likedBy",
CASE WHEN COUNT(v."user_id") > 0 THEN json_agg(v."user_id") ELSE '[]'::json END AS "uniqueViews"
FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p.id
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p.id
WHERE v.user_id = $1 
GROUP BY p.id
ORDER BY v.view_date asc
LIMIT $2
OFFSET $3
`

type GetAllProductViewParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllProductViewRow struct {
	ID                int64           `json:"id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetAllProductView(ctx context.Context, arg GetAllProductViewParams) ([]GetAllProductViewRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProductView, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductViewRow{}
	for rows.Next() {
		var i GetAllProductViewRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Image,
			&i.CountInStock,
			&i.Description,
			&i.Sold,
			&i.Discount,
			&i.DiscountStartDate,
			&i.DiscountEndDate,
			&i.Type,
			&i.Status,
			&i.Slug,
			&i.Price,
			&i.Location,
			&i.Views,
			&i.CreateAt,
			&i.TotalLikes,
			&i.LikedBy,
			&i.UniqueViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductById = `-- name: GetProductById :one
SELECT p.id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p.id
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p.id
WHERE p.id = $1 
GROUP BY p.id
LIMIT 1
`

type GetProductByIdRow struct {
	ID                int64           `json:"id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetProductById(ctx context.Context, id int64) (GetProductByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getProductById, id)
	var i GetProductByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT p.id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p.id
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p.id
WHERE p.slug = $1 
GROUP BY p.id
LIMIT 1
`

type GetProductBySlugRow struct {
	ID                int64           `json:"id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (GetProductBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getProductBySlug, slug)
	var i GetProductBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const getProductPublicById = `-- name: GetProductPublicById :one
SELECT p.id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p.id
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p.id
WHERE p.id = $1 
GROUP BY p.id
LIMIT 1
`

type GetProductPublicByIdRow struct {
	ID                int64           `json:"id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetProductPublicById(ctx context.Context, id int64) (GetProductPublicByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getProductPublicById, id)
	var i GetProductPublicByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const getProductRelated = `-- name: GetProductRelated :one
SELECT p.id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p.id
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p.id
WHERE p.type = $1 
GROUP BY p.id
LIMIT $2
OFFSET $3
`

type GetProductRelatedParams struct {
	Type   int32 `json:"type"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProductRelatedRow struct {
	ID                int64           `json:"id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              int32           `json:"sold"`
	Discount          int32           `json:"discount"`
	DiscountStartDate time.Time       `json:"discountStartDate"`
	DiscountEndDate   time.Time       `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             int32           `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetProductRelated(ctx context.Context, arg GetProductRelatedParams) (GetProductRelatedRow, error) {
	row := q.db.QueryRowContext(ctx, getProductRelated, arg.Type, arg.Limit, arg.Offset)
	var i GetProductRelatedRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const updateViewProduct = `-- name: UpdateViewProduct :exec
UPDATE "Product" SET views = $1
WHERE id = $2
`

type UpdateViewProductParams struct {
	Views int32 `json:"views"`
	ID    int64 `json:"id"`
}

func (q *Queries) UpdateViewProduct(ctx context.Context, arg UpdateViewProductParams) error {
	_, err := q.db.ExecContext(ctx, updateViewProduct, arg.Views, arg.ID)
	return err
}
