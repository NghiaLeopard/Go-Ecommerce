// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/lib/pq"
)

const createUserAdmin = `-- name: CreateUserAdmin :one
INSERT INTO "Users" (
  email,password,"firstName","lastName","middleName",avatar,address,"phoneNumber",role,city
) VALUES (
  $1,$2,$3,$4,$5,$6,$7,$8,$9,$10
)
RETURNING _id, email, password, "userType", status, address, avatar, image, "phoneNumber", role, "firstName", "lastName", "middleName", city, "likeProducts", "viewedProducts", "deviceToken", addresses, create_at
`

type CreateUserAdminParams struct {
	Email       string         `json:"email"`
	Password    string         `json:"password"`
	FirstName   sql.NullString `json:"firstName"`
	LastName    sql.NullString `json:"lastName"`
	MiddleName  sql.NullString `json:"middleName"`
	Avatar      sql.NullString `json:"avatar"`
	Address     sql.NullString `json:"address"`
	PhoneNumber sql.NullString `json:"phoneNumber"`
	Role        sql.NullInt64  `json:"role"`
	City        sql.NullInt64  `json:"city"`
}

func (q *Queries) CreateUserAdmin(ctx context.Context, arg CreateUserAdminParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUserAdmin,
		arg.Email,
		arg.Password,
		arg.FirstName,
		arg.LastName,
		arg.MiddleName,
		arg.Avatar,
		arg.Address,
		arg.PhoneNumber,
		arg.Role,
		arg.City,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.UserType,
		&i.Status,
		&i.Address,
		&i.Avatar,
		&i.Image,
		&i.PhoneNumber,
		&i.Role,
		&i.FirstName,
		&i.LastName,
		&i.MiddleName,
		&i.City,
		pq.Array(&i.LikeProducts),
		pq.Array(&i.ViewedProducts),
		pq.Array(&i.DeviceToken),
		&i.Addresses,
		&i.CreateAt,
	)
	return i, err
}

const deleteManyUserAdminByIds = `-- name: DeleteManyUserAdminByIds :exec
DELETE FROM "Users"
WHERE "_id" = ANY($1::bigint[])
`

func (q *Queries) DeleteManyUserAdminByIds(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.ExecContext(ctx, deleteManyUserAdminByIds, pq.Array(dollar_1))
	return err
}

const deleteUserAdminById = `-- name: DeleteUserAdminById :exec
DELETE FROM "Users"
WHERE "_id" = $1
`

func (q *Queries) DeleteUserAdminById(ctx context.Context, ID int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserAdminById, ID)
	return err
}

const getUserAdminByEmail = `-- name: GetUserAdminByEmail :one
SELECT _id, email, password, "userType", status, address, avatar, image, "phoneNumber", role, "firstName", "lastName", "middleName", city, "likeProducts", "viewedProducts", "deviceToken", addresses, create_at FROM "Users"
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserAdminByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserAdminByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.UserType,
		&i.Status,
		&i.Address,
		&i.Avatar,
		&i.Image,
		&i.PhoneNumber,
		&i.Role,
		&i.FirstName,
		&i.LastName,
		&i.MiddleName,
		&i.City,
		pq.Array(&i.LikeProducts),
		pq.Array(&i.ViewedProducts),
		pq.Array(&i.DeviceToken),
		&i.Addresses,
		&i.CreateAt,
	)
	return i, err
}

const getUserAdminById = `-- name: GetUserAdminById :one
SELECT 
  u."_id",
  COALESCE(u."firstName", '') AS "firstName",
  COALESCE(u."lastName", '') AS "lastName",
  COALESCE(u."address", '') AS "address",
  COALESCE(u."middleName", '') AS "middleName",
  COALESCE(u."email", '') AS "email",
  COALESCE(u."avatar", '') AS "avatar",
  COALESCE(u."phoneNumber", '') AS "phoneNumber",
  COALESCE(u."status", u."status") AS "status",
  COALESCE(u."userType", u."userType") AS "userType",
  json_build_object('_id', r."_id",'name', r.name) AS "role",
  COALESCE(c."_id", 0) AS "city",
  COUNT(u."_id") OVER() AS "totalCount" 
FROM "Users" u
LEFT JOIN "Role" r ON r."_id" = u."role"
LEFT JOIN "City" c ON c."_id" = u."city"
WHERE u."_id" = $1 LIMIT 1
`

type GetUserAdminByIdRow struct {
	ID          int64           `json:"_id"`
	FirstName   string          `json:"firstName"`
	LastName    string          `json:"lastName"`
	Address     string          `json:"address"`
	MiddleName  string          `json:"middleName"`
	Email       string          `json:"email"`
	Avatar      string          `json:"avatar"`
	PhoneNumber string          `json:"phoneNumber"`
	Status      UsersStatus     `json:"status"`
	UserType    UsersType       `json:"userType"`
	Role        json.RawMessage `json:"role"`
	City        int64           `json:"city"`
	TotalCount  int64           `json:"totalCount"`
}

func (q *Queries) GetUserAdminById(ctx context.Context, ID int64) (GetUserAdminByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserAdminById, ID)
	var i GetUserAdminByIdRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Address,
		&i.MiddleName,
		&i.Email,
		&i.Avatar,
		&i.PhoneNumber,
		&i.Status,
		&i.UserType,
		&i.Role,
		&i.City,
		&i.TotalCount,
	)
	return i, err
}

const listUserAdmin = `-- name: ListUserAdmin :many
SELECT 
  u."_id",
  COALESCE(u."firstName", '') AS "firstName",
  COALESCE(u."lastName", '') AS "lastName",
  COALESCE(u."middleName", '') AS "middleName",
  COALESCE(u."email", '') AS "email",
  COALESCE(u."phoneNumber", '') AS "phoneNumber",
  COALESCE(u."status", u."status") AS "status",
  COALESCE(u."userType", u."userType") AS "userType",
  json_build_object('_id', r."_id",'name', r.name) AS "role",
  json_build_object('_id', c."_id",'name', c.name) AS "city",
  COUNT(u."_id") OVER() AS "totalCount" 
FROM "Users" u
LEFT JOIN "Role" r ON r."_id" = u."role"
LEFT JOIN "City" c ON c."_id" = u."city"
WHERE  $1 ::text = '' or u."email" ILIKE concat('%',$1,'%')
ORDER BY 
  CASE 
        WHEN $2 = 'createdAt asc' THEN u.create_at END ASC,
  CASE 
        WHEN $2 = 'createdAt desc' THEN u.create_at END DESC
LIMIT NULLIF($4 :: int, 0)
OFFSET NULLIF($3 :: int, 0)
`

type ListUserAdminParams struct {
	Search    string      `json:"search"`
	OrderBy   interface{} `json:"order_by"`
	OffsetOpt int32       `json:"offset_opt"`
	LimitOpt  int32       `json:"limit_opt"`
}

type ListUserAdminRow struct {
	ID          int64           `json:"_id"`
	FirstName   string          `json:"firstName"`
	LastName    string          `json:"lastName"`
	MiddleName  string          `json:"middleName"`
	Email       string          `json:"email"`
	PhoneNumber string          `json:"phoneNumber"`
	Status      UsersStatus     `json:"status"`
	UserType    UsersType       `json:"userType"`
	Role        json.RawMessage `json:"role"`
	City        json.RawMessage `json:"city"`
	TotalCount  int64           `json:"totalCount"`
}

func (q *Queries) ListUserAdmin(ctx context.Context, arg ListUserAdminParams) ([]ListUserAdminRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserAdmin,
		arg.Search,
		arg.OrderBy,
		arg.OffsetOpt,
		arg.LimitOpt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserAdminRow{}
	for rows.Next() {
		var i ListUserAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.MiddleName,
			&i.Email,
			&i.PhoneNumber,
			&i.Status,
			&i.UserType,
			&i.Role,
			&i.City,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserAdmin = `-- name: UpdateUserAdmin :one
UPDATE "Users" SET "firstName" = $1,"lastName" = $2,"middleName" = $3,avatar = $4,address = $5,"phoneNumber" = $6,role = $7,city = $8,status = $9,update_at = NOW()
WHERE "_id" = $10
RETURNING _id, email, password, "userType", status, address, avatar, image, "phoneNumber", role, "firstName", "lastName", "middleName", city, "likeProducts", "viewedProducts", "deviceToken", addresses, create_at
`

type UpdateUserAdminParams struct {
	FirstName   sql.NullString `json:"firstName"`
	LastName    sql.NullString `json:"lastName"`
	MiddleName  sql.NullString `json:"middleName"`
	Avatar      sql.NullString `json:"avatar"`
	Address     sql.NullString `json:"address"`
	PhoneNumber sql.NullString `json:"phoneNumber"`
	Role        sql.NullInt64  `json:"role"`
	City        sql.NullInt64  `json:"city"`
	Status      UsersStatus    `json:"status"`
	ID          int64          `json:"_id"`
}

func (q *Queries) UpdateUserAdmin(ctx context.Context, arg UpdateUserAdminParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserAdmin,
		arg.FirstName,
		arg.LastName,
		arg.MiddleName,
		arg.Avatar,
		arg.Address,
		arg.PhoneNumber,
		arg.Role,
		arg.City,
		arg.Status,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.UserType,
		&i.Status,
		&i.Address,
		&i.Avatar,
		&i.Image,
		&i.PhoneNumber,
		&i.Role,
		&i.FirstName,
		&i.LastName,
		&i.MiddleName,
		&i.City,
		pq.Array(&i.LikeProducts),
		pq.Array(&i.ViewedProducts),
		pq.Array(&i.DeviceToken),
		&i.Addresses,
		&i.CreateAt,
	)
	return i, err
}
