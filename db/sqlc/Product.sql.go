// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: Product.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO "Product" (
  "name","image","countInStock","description","type","status","slug","price","discount","discountStartDate","discountEndDate","location"
) VALUES (
  $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12
)
RETURNING id, name, image, "countInStock", description, sold, discount, "discountStartDate", "discountEndDate", type, status, slug, price, location, views, create_at
`

type CreateProductParams struct {
	Name              string        `json:"name"`
	Image             string        `json:"image"`
	CountInStock      int32         `json:"countInStock"`
	Description       string        `json:"description"`
	Type              int32         `json:"type"`
	Status            int32         `json:"status"`
	Slug              string        `json:"slug"`
	Price             int32         `json:"price"`
	Discount          sql.NullInt32 `json:"discount"`
	DiscountStartDate sql.NullTime  `json:"discountStartDate"`
	DiscountEndDate   sql.NullTime  `json:"discountEndDate"`
	Location          int32         `json:"location"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Name,
		arg.Image,
		arg.CountInStock,
		arg.Description,
		arg.Type,
		arg.Status,
		arg.Slug,
		arg.Price,
		arg.Discount,
		arg.DiscountStartDate,
		arg.DiscountEndDate,
		arg.Location,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
	)
	return i, err
}

const createProductLike = `-- name: CreateProductLike :exec
INSERT INTO "Product_liked" (
  "product_id","user_id"
) VALUES (
  $1, $2
)
`

type CreateProductLikeParams struct {
	ProductID int32 `json:"product_id"`
	UserID    int32 `json:"user_id"`
}

func (q *Queries) CreateProductLike(ctx context.Context, arg CreateProductLikeParams) error {
	_, err := q.db.ExecContext(ctx, createProductLike, arg.ProductID, arg.UserID)
	return err
}

const createProductUniqueView = `-- name: CreateProductUniqueView :exec
INSERT INTO "Product_UniqueView" (
  "product_id","user_id"
) VALUES (
  $1, $2
)
`

type CreateProductUniqueViewParams struct {
	ProductID int32 `json:"product_id"`
	UserID    int32 `json:"user_id"`
}

func (q *Queries) CreateProductUniqueView(ctx context.Context, arg CreateProductUniqueViewParams) error {
	_, err := q.db.ExecContext(ctx, createProductUniqueView, arg.ProductID, arg.UserID)
	return err
}

const deleteLikedProductByUserId = `-- name: DeleteLikedProductByUserId :exec
DELETE FROM "Product_liked"
WHERE user_id = $1
`

func (q *Queries) DeleteLikedProductByUserId(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, deleteLikedProductByUserId, userID)
	return err
}

const deleteManyProductsByIds = `-- name: DeleteManyProductsByIds :exec
DELETE FROM "Product"
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteManyProductsByIds(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.ExecContext(ctx, deleteManyProductsByIds, pq.Array(dollar_1))
	return err
}

const deleteProductById = `-- name: DeleteProductById :exec
DELETE FROM "Product"
WHERE id = $1
`

func (q *Queries) DeleteProductById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProductById, id)
	return err
}

const getAllProductLike = `-- name: GetAllProductLike :one
SELECT p.id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p.id
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p.id
WHERE l.user_id = $1 
GROUP BY p.id
LIMIT 1
`

type GetAllProductLikeRow struct {
	ID                int64           `json:"id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              sql.NullInt32   `json:"sold"`
	Discount          sql.NullInt32   `json:"discount"`
	DiscountStartDate sql.NullTime    `json:"discountStartDate"`
	DiscountEndDate   sql.NullTime    `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             sql.NullInt32   `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetAllProductLike(ctx context.Context, userID int32) (GetAllProductLikeRow, error) {
	row := q.db.QueryRowContext(ctx, getAllProductLike, userID)
	var i GetAllProductLikeRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const getAllProductView = `-- name: GetAllProductView :one
SELECT p.id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p.id
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p.id
WHERE v.user_id = $1 
GROUP BY p.id
LIMIT 1
`

type GetAllProductViewRow struct {
	ID                int64           `json:"id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              sql.NullInt32   `json:"sold"`
	Discount          sql.NullInt32   `json:"discount"`
	DiscountStartDate sql.NullTime    `json:"discountStartDate"`
	DiscountEndDate   sql.NullTime    `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             sql.NullInt32   `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetAllProductView(ctx context.Context, userID int32) (GetAllProductViewRow, error) {
	row := q.db.QueryRowContext(ctx, getAllProductView, userID)
	var i GetAllProductViewRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const getProductById = `-- name: GetProductById :one
SELECT p.id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p.id
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p.id
WHERE p.id = $1 
GROUP BY p.id
LIMIT 1
`

type GetProductByIdRow struct {
	ID                int64           `json:"id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              sql.NullInt32   `json:"sold"`
	Discount          sql.NullInt32   `json:"discount"`
	DiscountStartDate sql.NullTime    `json:"discountStartDate"`
	DiscountEndDate   sql.NullTime    `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             sql.NullInt32   `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetProductById(ctx context.Context, id int64) (GetProductByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getProductById, id)
	var i GetProductByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT p.id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p.id
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p.id
WHERE p.slug = $1 
GROUP BY p.id
LIMIT 1
`

type GetProductBySlugRow struct {
	ID                int64           `json:"id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              sql.NullInt32   `json:"sold"`
	Discount          sql.NullInt32   `json:"discount"`
	DiscountStartDate sql.NullTime    `json:"discountStartDate"`
	DiscountEndDate   sql.NullTime    `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             sql.NullInt32   `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (GetProductBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getProductBySlug, slug)
	var i GetProductBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const getProductPublicById = `-- name: GetProductPublicById :one
SELECT p.id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p.id
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p.id
WHERE p.id = $1 
GROUP BY p.id
LIMIT 1
`

type GetProductPublicByIdRow struct {
	ID                int64           `json:"id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              sql.NullInt32   `json:"sold"`
	Discount          sql.NullInt32   `json:"discount"`
	DiscountStartDate sql.NullTime    `json:"discountStartDate"`
	DiscountEndDate   sql.NullTime    `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             sql.NullInt32   `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetProductPublicById(ctx context.Context, id int64) (GetProductPublicByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getProductPublicById, id)
	var i GetProductPublicByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const getProductRelated = `-- name: GetProductRelated :one
SELECT p.id, p.name, p.image, p."countInStock", p.description, p.sold, p.discount, p."discountStartDate", p."discountEndDate", p.type, p.status, p.slug, p.price, p.location, p.views, p.create_at,COUNT(l."user_id") AS "totalLikes",
json_agg(l."user_id") AS "likedBy",
json_agg(v."user_id") AS "uniqueViews" FROM "Product" p
LEFT JOIN "Product_liked" l ON l."product_id" = p.id
LEFT JOIN "Product_UniqueView" v ON v."product_id" = p.id
WHERE p.type = $1 
GROUP BY p.id
LIMIT $2
OFFSET $3
`

type GetProductRelatedParams struct {
	Type   int32 `json:"type"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProductRelatedRow struct {
	ID                int64           `json:"id"`
	Name              string          `json:"name"`
	Image             string          `json:"image"`
	CountInStock      int32           `json:"countInStock"`
	Description       string          `json:"description"`
	Sold              sql.NullInt32   `json:"sold"`
	Discount          sql.NullInt32   `json:"discount"`
	DiscountStartDate sql.NullTime    `json:"discountStartDate"`
	DiscountEndDate   sql.NullTime    `json:"discountEndDate"`
	Type              int32           `json:"type"`
	Status            int32           `json:"status"`
	Slug              string          `json:"slug"`
	Price             int32           `json:"price"`
	Location          int32           `json:"location"`
	Views             sql.NullInt32   `json:"views"`
	CreateAt          time.Time       `json:"create_at"`
	TotalLikes        int64           `json:"totalLikes"`
	LikedBy           json.RawMessage `json:"likedBy"`
	UniqueViews       json.RawMessage `json:"uniqueViews"`
}

func (q *Queries) GetProductRelated(ctx context.Context, arg GetProductRelatedParams) (GetProductRelatedRow, error) {
	row := q.db.QueryRowContext(ctx, getProductRelated, arg.Type, arg.Limit, arg.Offset)
	var i GetProductRelatedRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.CountInStock,
		&i.Description,
		&i.Sold,
		&i.Discount,
		&i.DiscountStartDate,
		&i.DiscountEndDate,
		&i.Type,
		&i.Status,
		&i.Slug,
		&i.Price,
		&i.Location,
		&i.Views,
		&i.CreateAt,
		&i.TotalLikes,
		&i.LikedBy,
		&i.UniqueViews,
	)
	return i, err
}

const updateViewProduct = `-- name: UpdateViewProduct :exec
UPDATE "Product" SET views = $1
WHERE id = $2
`

type UpdateViewProductParams struct {
	Views sql.NullInt32 `json:"views"`
	ID    int64         `json:"id"`
}

func (q *Queries) UpdateViewProduct(ctx context.Context, arg UpdateViewProductParams) error {
	_, err := q.db.ExecContext(ctx, updateViewProduct, arg.Views, arg.ID)
	return err
}
